<b>Scripting APIs</b><br><br>If you are not happy with what the present tooling of the TraceDebugger offers, of course you are invited to open an issue in the repository! Apart from that, here is short summary of relevant interfaces that you might want to use to assemble some information about a program trace yourself. Hand me a workspace with all code snippets.<br><br><b>Recording a program trace</b><br>cursor <b>:=</b> TDBCursor traceForBlock: ['\w+' asRegex].<br><br><b>Accessing the context tree</b> (like the TraceDebugger does)<br>root <b>:=</b> cursor context tdbFullStack first. <i>&quot;[] in UndefinedObject&gt;&gt;DoIt&quot;</i><br>children <b>:=</b> cursor childContextsFor: root.<br>firstChild <b>:=</b> children first. <i>&quot;ByteString(String)&gt;&gt;asRegex&quot;</i><br>someContext <b>:=</b> cursor findContextSuchThat: [:ctx | ctx method == (PositionableStream class&gt;&gt;#on:)]. <i>&quot;ReadStream class(PositionableStream class)&gt;&gt;on:&quot;</i><br>someContext sender. <i>&quot;RxParser&gt;&gt;parse:&quot;<br></i>stream <b>:=</b> cursor returnValueFor: someContext ifPresent: #yourself. <i>&quot;a ReadStream&quot;</i><br><br>Do <u>not</u> manually access the trace instances. They are an implementation detail of the cursor and subjected to change. See the class comment for more information.<br><br><b>Stepping through a program trace</b> (like the TraceDebugger does)<br>See the <a href="code://ToolSet browseClass: TDBCursor category: 'stepping'">stepping protocol</a> and TDBCursor exampleStepping.<br><br>For more information on the cursor interface, do this:<br>cursor exploreProtocol.<br><br><b>Accessing historic values</b> (like the snapshot inspectors do)<br>All historic values are stored in the cursor's <a href="code://ToolSet browse: TDBCursor selector: #memory">memory</a> and can be conveniently accessed through transparent <a href="code://ToolSet browse: TDBCursor selector: #object:atTime:">proxies</a> that just behave like the requested object at a certain time. Proxies can be sent further messages to access their state, all relevant answers will be wrapped in further proxy instances.<br><br>(cursor object: stream atTime: 0) position. <i>&quot;nil&quot;</i><br>(cursor object: stream atTime: (cursor maxTimeIndexFor: someContext)) position. <i>&quot;0&quot;</i><br>(cursor object: stream atTime: (cursor maxTimeIndexFor: root)) position. <i>&quot;3&quot;</i><br><br>Note that all side effects during a proxy access will be isolated, so for instance, sending a proxy the message #printOn: will not actually modify the passed stream instance.<br><br>(cursor object: stream atTime: (cursor maxTimeIndexFor: someContext)) next. <i>&quot;$\&quot;</i><br><br>For more details, refer to the comment in TDBProxy. If you ever need to escape from proxy hell, send aProxy copy tdbproxyYourself. See flag <a href="code://self systemNavigation browseAllImplementorsOf: #proxyHacks">#proxyHacks</a>.<br><br><b>Accessing historic ranges</b> (like the history explorer does)<br>cursor object: stream collect: #position. <i>&quot;a TDBMemorySlice(... (0 to: 28) -&gt; nil (29 to: 55) -&gt; 0 (56 to: 174) -&gt; 1 (175 to: 299) -&gt; 2 (300 to: 2338) -&gt; 3) ...)&quot;<br></i>cursor memory object: stream atTimes: ((cursor minTimeIndexFor: someContext) to: (cursor maxTimeIndexFor: someContext)) collect: #position. <i>&quot;a TDBMemorySlice(... (18 to: 28) -&gt; nil (29 to: 36) -&gt; 0) ...)&quot;<br></i><br>The following example illustrates that historic range queries typically need to perform a lot of error handling and need to copy objects for later reuse (<a href="code://self systemNavigation browseAllImplementorsOf: #proxyHacks">#proxyHacks</a>):<i><br></i><br>cursor object: stream collect: [:ea | [(ea originalContents first: ea position) copy] on: Error do: #yourself]. <i>&quot;a TDBMemorySlice((0 to: 23) -&gt; MessageNotUnderstood: UndefinedObject&gt;&gt;first: (24 to: 28) -&gt; MessageNotUnderstood: UndefinedObject&gt;&gt;- (29 to: 55) -&gt; '' (56 to: 174) -&gt; '\' (175 to: 299) -&gt; '\w' (300 to: 2338) -&gt; '\w+')&quot;</i><br><br>The resulting memory slices can be accessed and transformed. Noticeably, when you operate on the discretized values from a memory slice, your code will likely operate on transparent <a href="code://TDBMemorySlice>>#rangeValueAtTime:">range proxies</a> that represent a value in an entire time range. A range proxy will behave similar to a normal proxy, but if it is sent further messages that reveal any state that has changed within the time range, the proxy will signal a fray out error. For more details, please refer to the class comments in TDBMemorySlice and TDBRangeProxy.