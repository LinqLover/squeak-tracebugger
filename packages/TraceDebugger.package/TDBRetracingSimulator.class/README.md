I modify code simulation to emulate an earlier version of the state (memory) that the code is accessing. To do this, subclasses have to overwrite the read state hooks from my superclass and redirect read accesses so that an older version of the requested state is returned if available. Furthermore, I enable isolated execution (see #initialize), and I provide a small #TraceDebugger primitive module to the executed code for metaprogramming purposes (e.g., see Context>>#tdbRetracingTimeIndex).

I am the abstract superclass for retracing. My reference implementation can be found in the TDBPointRetracingSimulator subclass. On my class side, clients can find a factory facade for different retracers.