I am the main and facade class for trace-debugging. Clients can trace and retrace programs by instantiating me with a block or context and using my stepping protocol (inspired by Squeak's default Debugger) to time-travel through the traced execution. Clients can retrieve historic states from the program trace by sending #context: or #object:[atTime:|collect:]. Clients can also send me some queries about the trace or apply filters to it. See my class side for some examples.

Internally, I manage a TDBTrace tree and a timeIndex that points on a point in time of the trace. When sent any stepping message, I move the timeIndex to focus the desired context at the expected state. I implement lazy tracing, i.e., the trace will be only advanced during stepping as far as required (see #basicStep). To record historic states, execution of the code will happen in a TDBTracingSimulator which stores all side effects in a TDBMemory. To read out historic states, #context: and #object:[atTime:] answer TDBProxys that model the virtual historic state space.

Note that TDBTrace is only an internal data structure and not part of the public protocol. Currently, clients are expected to work with the contexts directly and request additional infos such as children or return value from the cursor. This has the advantage of preserving compatibility with the normal context interface which is used for instance in the debugger. A public "traced context" class that provides #returnValue et al. directly is not planned at the moment.

For more details on scripting with the TraceDebugger, refer to my class-side examples and the help on Scripting APIs.